#!/bin/bash
#
# Copyright and License information can be found in the file
# license.txt or license.html
#
trap 'echo scvs test driver interrupted; exit' 2 3 5 15
# overwrite the test.log file in test directory, put in a simple header
echo `date` > test.log
echo >> test.log
echo ------- >> test.log
echo >> test.log
#
output=0
single=0
VERSION=0.0B
DATE=2012-09-20
SINGLE=
OUTPUT=
RULE_LIST=rule_list
CMD=default_cmds
CONFIGFILE=configuration.txt
OLDCONFIGFILE=configuration.old

#
# a local function to build the configuration file that is 
# used by the reporter.
#
function mk_config_file() {
 if [ -e $CONFIGFILE ]
 then
   mv $CONFIGFILE $OLDCONFIGFILE
 fi
 echo "# This file is generated by the SCVS test driver" > $CONFIGFILE
 echo "# This file should not be edited. " >> $CONFIGFILE
 echo "#" >> $CONFIGFILE
 echo DATE=`date` >> $CONFIGFILE
 echo TESTER=$LOGNAME >> $CONFIGFILE
 echo TEST_DIRECTORY=$PWD >> $CONFIGFILE
 echo TEST_SCRIPT=$CMD >> $CONFIGFILE
 echo VERSION=$VERSION >> $CONFIGFILE
 if [ $single == 0 ]
 then
  echo RULE_LIST=$RULE_LIST >> $CONFIGFILE
 else
  echo SINGLE=$SINGLE >> $CONFIGFILE
 fi
}
#
# missing argument 
#
missing_argument() {
 echo
 echo option $1 requires an argument
 show_help
 exit 0
}
#
# usage
#
show_help() {
 echo
 echo >&2 $" Usage: test-driver.sh [OPTIONS]
  -l=FILE, --list=FILE	List of directories to test, default is rule_list, 
                        the rule_list file contains all the current test 
                        directories.  Each directory corresponds with a single
                        rule in TS 17961, the rules are also in the same order
                        as they are defined in TS 17961.
  -s=DIR, --single=DIR	The directory associated with the single rule to test.
  -c=FILE, --cmd=FILE	The script that holds the commands for the 
                        implementation being tested. Default is default_cmd.  
                        There are several shipped with the test suite that can
                        be used as examples.  See the README file in the top
                        directory.
  -o=FILE, --output=FILE	Put all output to FILE.
  -?, -h, --help	Print a short usage message then exit.
  -V, --version		Print version information then exit.
  -v, --verbose         Print detailed report of the test run results.
  -d, --debug		Print detailed report, showing all diagnostics found by
                        line number.  Sets the verbose flag.
 " 
 echo
 exit 0
}
#
# show version
#
show_version() {
 echo
 echo test-driver Version: $VERSION - $DATE
 echo
 exit 0;
}
#
# if no argument then use the default command list file, if argument 
# check to see if it is an executable file, or directory, or one of each.
# if the argument is a directory, set the single flag and use that directory
# to test a single rule.
# if the argument is a file, use the file as a list of directories to test.
#
while test $# -gt 0 ; do
  case "$1" in
   -V | --version)
   show_version
  ;;
   -\? | -h | --h | --help)
   show_help 
  ;;
  -v | --verbose)
   VERBOSE=-v
   shift
  ;;
  -d | --debug)
   DEBUG=-d
   shift
  ;;
  -l* | --list=*)
   RULE_LIST=${1##*=}
   if [ -f $RULE_LIST ]
   then
     echo setting directory list to $RULE_LIST
   else
     echo The directory list must be a readable file.  
     exit 0
   fi
   shift
  ;;
  -s=* | --single=*)
   SINGLE=${1##*=}
   if [ -d $SINGLE ]
   then
    echo setting single to $SINGLE
   else
    echo $SINGLE must be a directory, associated with a rule
    exit 0
   fi
   single=1
   shift
  ;;
  -c=* | --cmd=*)
   CMD=${1##*=}
   if [ -f $CMD ]
   then
    echo setting cmd to $CMD
   else
    echo $CMD must be an executable shell script
    exit 0
   fi
   shift
  ;;
  -o=* | --output=*)
   OUTPUT=${1##*=}
   shift
  ;;
  *)
   echo
   echo $1 is an unknow option for $0. 
   exit 0
  ;;
 esac
done

dir_cnt=0
lin_cnt=0

# make files need the include
if [ -z $INCLUDE ]
then
  export INCLUDE="-I./ -I../../../include/"
fi

# use gcc as a default for the make file
if [ -z $CC ]
then
  export CC="gcc -std=c99"
fi

# set a default for the TAINT environment variable
if [ -z $TAINT ]
then
  export TAINT=555
fi

echo >> test.log
echo Using environment variables, CC = $CC, INCLUDE = $INCLUDE, and TAINT = $TAINT >> test.log
echo >> test.log

PATH=$PWD:$PATH

if [ /$CMD/ = /default_cmd/ ]
then
  if [ -x $CMD ]
  then
    echo Using default commands file.
  else
    echo $CMD is not executable.
    exit 0
  fi
fi

# make the configuration file for the reporter
mk_config_file

if [ $single -eq 0 ]
then
# use the list of directories as a list
# cd into the directory then use the command
# supplied as an argument or use the default
# command script
# 
# the '#' char is used to comment or 
# comment out entries.
 while read line
 do
  let "lin_cnt+=1"
  echo $line | grep -q '#'
  if [ $? -ne 0 ]
  then
   echo >> test.log
   echo Testing rule $line: >> test.log
   echo Testing rule $line: 
   echo >> test.log
   let "dir_cnt+=1"
   cd $line
   $CMD $line >> ../test.log 2>&1
   cd ..
   echo >> test.log
   echo ------- >> test.log
   echo >> test.log
  fi
 done < $RULE_LIST
 echo Total rules tested: $dir_cnt
 echo Total line count in $RULE_LIST file: $lin_cnt
else
echo testing single rule: $SINGLE
 cd $SINGLE
 $CMD $SINGLE >> ../test.log 2>&1
 cd ..
 echo >> test.log
 echo ------- >> test.log
 echo >> test.log
fi
# now call the reporter
if [ /$OUTPUT/ != // ]
then
  ./reporter $VERBOSE $DEBUG > $OUTPUT 2>&1
else 
  ./reporter $VERBOSE $DEBUG
fi
exit 1
